name: Deploy via Tailscale (reusable)

'on':
  workflow_call:
    inputs:
      build_cmd:
        description: Optional build step executed on the runner before deploy
        required: false
        type: string
        default: ""
      remote_repo_path:
        description: Path to the repo on the server (e.g. ~/mmc-infrastructure)
        required: true
        type: string
      remote_branch:
        description: Git branch to deploy on the server
        required: false
        type: string
        default: production
      git_clean_exclude:
        description: Optional path to exclude from git clean
        required: false
        type: string
        default: ""
      deploy_cmd:
        description: Shell commands executed on the server after updating the repo
        required: true
        type: string
      tailscale_tags:
        description: Optional comma-separated Tailscale tags (defaults to vars.TS_TAGS or tag:ci)
        required: false
        type: string
        default: ""
      known_hosts:
        description: Optional known_hosts entries to use instead of ssh-keyscan (more secure, avoids TOFU)
        required: false
        type: string
        default: ""
      remote_preflight_cmd:
        description: Optional shell commands executed on the server before rsync/deploy (non-secret)
        required: false
        type: string
        default: ""
      write_deploy_metadata:
        description: Write a deploy metadata JSON file into the remote path (repo, sha, timestamp)
        required: false
        type: boolean
        default: false
      deploy_metadata_filename:
        description: Filename for deploy metadata (relative to remote path)
        required: false
        type: string
        default: ".deploy-meta.json"
      debug:
        description: Enable verbose runner logging (no secret values)
        required: false
        type: boolean
        default: false
    secrets:
      TS_OAUTH_CLIENT_ID:
        required: true
      TS_OAUTH_SECRET:
        required: true
      DEPLOY_HOST:
        required: true
      DEPLOY_USER:
        required: true
      DEPLOY_SSH_KEY:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
      TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
      ORG_TS_TAGS: ${{ vars.TS_TAGS }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          # In a reusable workflow, actions/checkout would otherwise check out the workflow repo.
          repository: ${{ github.repository }}
          ref: ${{ github.sha }}
          fetch-depth: 1

      - name: Build
        if: ${{ inputs.build_cmd != '' }}
        run: |
          set -euo pipefail
          ${{ inputs.build_cmd }}

      - name: Validate deploy secrets
        run: |
          set -euo pipefail
          [ -n "$DEPLOY_HOST" ] || { echo "::error::DEPLOY_HOST secret is missing"; exit 1; }
          [ -n "$DEPLOY_USER" ] || { echo "::error::DEPLOY_USER secret is missing"; exit 1; }
          [ -n "$DEPLOY_SSH_KEY" ] || { echo "::error::DEPLOY_SSH_KEY secret is missing"; exit 1; }
          [ -n "$TS_OAUTH_CLIENT_ID" ] || { echo "::error::TS_OAUTH_CLIENT_ID secret is missing"; exit 1; }
          [ -n "$TS_OAUTH_SECRET" ] || { echo "::error::TS_OAUTH_SECRET secret is missing"; exit 1; }

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: ${{ inputs.tailscale_tags != '' && inputs.tailscale_tags || (vars.TS_TAGS != '' && vars.TS_TAGS || 'tag:ci') }}
          ping: ${{ secrets.DEPLOY_HOST }}

      - name: Deploy on server
        env:
          INPUT_KNOWN_HOSTS: ${{ inputs.known_hosts }}
          INPUT_REMOTE_PREFLIGHT_CMD: ${{ inputs.remote_preflight_cmd }}
          INPUT_DEPLOY_CMD: ${{ inputs.deploy_cmd }}
        run: |
          set -euo pipefail

          if [[ '${{ inputs.debug }}' == 'true' ]]; then
            set -x
          fi

          install -m 700 -d ~/.ssh
          # Never echo the private key, even in debug mode.
          set +x
          printf '%s\n' "$DEPLOY_SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          if [[ '${{ inputs.debug }}' == 'true' ]]; then
            set -x
          fi

          if [[ '${{ inputs.known_hosts != '' }}' == 'true' ]]; then
            printf '%s\n' "$INPUT_KNOWN_HOSTS" >> ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          fi

          ssh_opts=(
            -i ~/.ssh/id_ed25519
            -o BatchMode=yes
            -o IdentitiesOnly=yes
            -o StrictHostKeyChecking=yes
            -o UserKnownHostsFile=~/.ssh/known_hosts
            -o ConnectTimeout=15
          )
          ssh_cmd=(ssh "${ssh_opts[@]}")
          rsync_ssh="ssh -i ~/.ssh/id_ed25519 -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o ConnectTimeout=15"

          if ! command -v rsync >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y rsync
          fi

          echo "::notice::Deploying ${{ github.repository }}@${{ github.sha }} to $DEPLOY_HOST"

          # Expand ~/... to an absolute path on the server.
          echo "::group::Resolve remote path"
          remote_home=$("${ssh_cmd[@]}" "$DEPLOY_USER@$DEPLOY_HOST" 'printf %s "$HOME"')
          remote_path='${{ inputs.remote_repo_path }}'
          if [[ "$remote_path" == "~/"* ]]; then
            remote_path="$remote_home/${remote_path#~/}"
          elif [[ "$remote_path" == /* ]]; then
            :
          else
            remote_path="$remote_home/$remote_path"
          fi
          echo "remote_home=$remote_home"
          echo "remote_path=$remote_path"
          echo "::endgroup::"

          echo "::group::Ensure remote dir"
          printf 'set -euo pipefail\nmkdir -p "$REMOTE_PATH"\n' | "${ssh_cmd[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "REMOTE_PATH='$remote_path' bash -seuo pipefail"
          echo "::endgroup::"

          if [[ '${{ inputs.remote_preflight_cmd != '' }}' == 'true' ]]; then
            echo "::group::Remote preflight"
            {
              printf 'set -euo pipefail\ncd "$REMOTE_PATH"\n'
              printf '%s\n' "$INPUT_REMOTE_PREFLIGHT_CMD"
            } | "${ssh_cmd[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "REMOTE_PATH='$remote_path' bash -seuo pipefail"
            echo "::endgroup::"
          fi

          # Sync repository contents to server (server does not need GitHub deploy keys).
          excludes=("--exclude=.git/")
          exclude_raw='${{ inputs.git_clean_exclude }}'
          if [ -n "$exclude_raw" ]; then
            while IFS= read -r line; do
              # trim leading/trailing whitespace
              line="${line#"${line%%[![:space:]]*}"}"
              line="${line%"${line##*[![:space:]]}"}"
              [ -n "$line" ] || continue
              excludes+=("--exclude=$line")
            done <<< "$exclude_raw"
          fi

          # Avoid preserving owner/group/perms; some paths on the server may be root-owned.
          # Keep symlinks and file mtimes; omit dir mtimes to reduce permission-related failures.
          echo "::group::rsync"
          rsync -rltz --delete --omit-dir-times -e "$rsync_ssh" "${excludes[@]}" ./ "$DEPLOY_USER@$DEPLOY_HOST:$remote_path/"
          echo "::endgroup::"

          if [[ '${{ inputs.write_deploy_metadata }}' == 'true' ]]; then
            echo "::group::Write deploy metadata"
            {
              printf '%s\n' 'set -euo pipefail'
              printf '%s\n' 'cd "$REMOTE_PATH"'
              printf '%s\n' 'now="$(date -Is)"'
              printf '%s\n' 'meta_path="$REMOTE_PATH/$DEPLOY_META_FILE"'
              printf '%s\n' 'tmp="$meta_path.tmp.$$"'
              printf '%s\n' 'printf '"'"'{"repository":"%s","sha":"%s","deployed_at":"%s"}\n'"'"' "$GITHUB_REPOSITORY" "$GITHUB_SHA" "$now" > "$tmp"'
              printf '%s\n' 'mv -f "$tmp" "$meta_path"'
            } | "${ssh_cmd[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "REMOTE_PATH='$remote_path' GITHUB_SHA='${{ github.sha }}' GITHUB_REPOSITORY='${{ github.repository }}' DEPLOY_META_FILE='${{ inputs.deploy_metadata_filename }}' bash -seuo pipefail"
            echo "::endgroup::"
          fi

          echo "::group::Remote deploy"
          {
            printf 'set -euo pipefail\ncd "$REMOTE_PATH"\necho "[deploy] host=$(hostname) user=$(whoami) path=$PWD repo=$GITHUB_REPOSITORY sha=$GITHUB_SHA"\n'
            printf '%s\n' "$INPUT_DEPLOY_CMD"
          } | "${ssh_cmd[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "REMOTE_PATH='$remote_path' GITHUB_SHA='${{ github.sha }}' GITHUB_REPOSITORY='${{ github.repository }}' bash -seuo pipefail"
          echo "::endgroup::"
